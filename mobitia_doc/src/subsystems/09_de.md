### 2.9 最適化アルゴリズム: 差分進化 (`src/slam/differential_evolution.rs`)
このモジュールは、SLAMの自己位置推定（スキャンマッチング）において、最適化問題を解くための差分進化 (Differential Evolution, DE) アルゴリズムを実装しています。`SlamManager` から呼び出され、現在のスキャンデータと地図が最もよく一致するロボットの姿勢を探索します。

#### `DifferentialEvolutionSolver` 構造体
DEアルゴリズムのソルバーであり、関連する設定と、スコア計算に用いるガウシアンカーネルを保持します。

```rust
pub struct DifferentialEvolutionSolver {
    gaussian_kernel: GaussianKernel,
    pub(crate) config: SlamConfig,
}
```

#### `optimize_de` (最適化の実行)
差分進化アルゴリズムのメイン関数です。

1.  **初期化**:
    - `config.toml` からDEのパラメータ（`population_size`, `generations`, `f_de`, `cr` など）を読み込みます。
    - ロボットの現在姿勢 `initial_pose` と、オドメトリによる移動推測量 `odom_guess` を基に、探索中心 `(center_x, center_y, center_a)` を決定します。
    - 探索中心の周囲に、`population_size` 個の個体（それぞれがロボットの姿勢 `(x, y, angle)` を示す）をランダムにばらまき、初期個体群 `population` を生成します。
2.  **評価**:
    - 初期個体群の各個体について、その姿勢をとった場合のスコアを `gaussian_match_count` で計算します。
3.  **進化**:
    - `generations` の数だけ世代交代を繰り返します。
    - 各世代で、個体群の全ての個体 `i` について以下の処理を行います。
        1.  **突然変異 (Mutation)**: 個体群からランダムに3つの異なる個体 `r1, r2, r3` を選び、`p_r1 + F * (p_r2 - p_r3)` という計算で変異ベクトル `v` を生成します（`F`はスケール因子`f_de`）。
        2.  **交叉 (Crossover)**: 元の個体 `i` と変異ベクトル `v` の間で、`cr` (交叉確率) に基づいて成分を混ぜ合わせ、新しい試験個体 `trial_pose` を生成します。
        3.  **選択 (Selection)**: 試験個体 `trial_pose` のスコアを `gaussian_match_count` で評価します。もし試験個体のスコアが元の個体 `i` のスコアより高ければ、個体 `i` を試験個体で置き換えます。
4.  **終了**:
    - 全ての世代が終了した後、最も高いスコアを持つ個体を最適解 `best_transform` として返します。

#### `gaussian_match_count` (スコア計算)
指定された姿勢 `pose` における、スキャンデータと地図の一致度（スコア）を計算する関数です。スコアが高いほど、よく一致していることを意味します。

スコアは以下の要素の重み付き和で計算されます。

1.  **位置スコア**:
    - スキャン点 `p` を `pose` で地図上に変換した点 `transformed_p` を計算します。
    - `transformed_p` の周辺にある地図上の占有セルを探します。
    - `transformed_p` と地図上の占有セルとの距離が近いほど、またそのセルの占有確率が高いほど、高いスコアを与えます（ガウス関数で計算）。
2.  **特徴類似度スコア**:
    - スキャン点の特徴（`edge_ness`）と、対応する地図セルの特徴（`edge_ness`）が類似しているほど高いスコアを与えます。
3.  **法線類似度スコア**:
    - スキャン点の法線ベクトルと、対応する地図セルの法線ベクトルの内積を計算します。向きが揃っているほど高いスコアになります。
4.  **コーナー点スコア**:
    - `raw_corner_points`（スキャンデータの中でも特にコーナーらしい点）について、対応する地図上のセルもコーナーらしい（`corner_ness`が高い）場合に、追加のスコアを与えます。

```rust
// gaussian_match_count のスコア計算部分の抜粋
fn gaussian_match_count(
    &self,
    // ...
) -> f64 {
    let mut total_score = 0.0;
    for (p_coord, scan_feature, scan_nx, scan_ny) in points {
        // ... (transformed_p, transformed_normal の計算) ...
        let mut point_score = 0.0;
        for dy in -kernel_radius..=kernel_radius {
            for dx in -kernel_radius..=kernel_radius {
                // ... (kernel_weight, cell_data の取得) ...
                
                // 1. 位置スコア
                let position_score = // ... ガウス関数による距離ペナルティ ...

                // 2. 特徴類似度スコア
                let feature_similarity = scan_feature_f64 * map_edgeness + (1.0 - scan_feature_f64) * (1.0 - map_edgeness);

                // 3. 法線類似度スコア
                let normal_similarity = (transformed_normal.x as f64 * map_normal_x + transformed_normal.y as f64 * map_normal_y).max(0.0);

                let combined_score = (position_score * self.config.position_score_weight)
                    + (feature_similarity * self.config.feature_score_weight)
                    + (normal_similarity * self.config.normal_alignment_score_weight);
                
                point_score += combined_score * kernel_weight;
            }
        }
        total_score += point_score;
    }

    // 4. コーナー点スコア
    total_score += corner_match_score * self.config.corner_score_weight;

    total_score
}
```